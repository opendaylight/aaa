package org.opendaylight.aaa.util;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import javax.xml.transform.stream.StreamSource;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.HashSet;
import java.util.Set;
/*
 * Data Encrypter is a simple API to encrypt and decrypt strings based on a key generated by the GenerateKey class.
 */
public class DataEncrypter {

    public static final String ENCRYPTED_TAG = "Encrypted:";
    private static final Set<TAG> tagsToEncrypt = new HashSet<TAG>();

    static {
        init();
    }

    //Read the key and install the different tags to seek in the xml config files
    //Currently it is only seeking "password"
    private static final void init() {
        tagsToEncrypt.add(new TAG("password"));

        if (GenerateKey.key == null) {
            File keyFile = new File(GenerateKey.PATH_TO_KEY);
            if(keyFile.exists()) {
                byte keyData[] = new byte[(int) keyFile.length()];
                try {
                    FileInputStream in = new FileInputStream(keyFile);
                    in.read(keyData);
                    in.close();
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                GenerateKey.key = new SecretKeySpec(keyData, "AES");
            }else{
                GenerateKey.generateKey();
            }
        }
    }

    public static final void addTag(String tag){
        tagsToEncrypt.add(new TAG(tag));
    }

    /**
     * Encrypt a string and return its encrypted string representation with a prefix encrypted tag.
     * The method with encrypt the string only if there is a valid key in the GenerateKey.key member.
     * If the string is already encrypted, it will not encrypt it twice.
     *
     * @param  str  The String to be encrypted
     * @return      The Encrypted String representation with a prefix tag
     */
    public static String encrypt(String str) {
        // No Key, hence disabled
        if (GenerateKey.key == null) {
            return str;
        }
        //null
        if(str==null){
            return str;
        }
        //already encrypted
        if (str.startsWith(ENCRYPTED_TAG)) {
            return str;
        }

        Cipher cr = null;
        try {
            cr = Cipher.getInstance("AES/CFB8/NoPadding");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return str;
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
            return str;
        }

        try {
            cr.init(Cipher.ENCRYPT_MODE, GenerateKey.key, GenerateKey.ivspec);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            return str;
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            return str;
        }

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        CipherOutputStream out = new CipherOutputStream(bout, cr);
        try {
            byte[] data = str.getBytes();
            out.write(data);
            out.close();
            byte[] encData = bout.toByteArray();
            return ENCRYPTED_TAG + DatatypeConverter.printBase64Binary(encData);
        }catch(IOException e){
            e.printStackTrace();
        }
        return str;
    }

    /**
     * Decrypt a tagged encrypted by the "encrypt" method. Will not decrypt if the string is not encrypted.
     * @param  encStr  The Tagged Encrypted String
     * @return         The unencrypted string.
     */
    public static String decrypt(String encStr) {
        // No Key, hence disabled
        if (GenerateKey.key == null) {
            return encStr;
        }
        //null
        if(encStr==null)
            return null;
        //is not encrypted with this util
        if (!encStr.startsWith(ENCRYPTED_TAG)) {
            return encStr;
        }

        Cipher cr = null;
        try {
            cr = Cipher.getInstance("AES/CFB8/NoPadding");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return encStr;
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
            return encStr;
        }

        try {
            cr.init(Cipher.DECRYPT_MODE, GenerateKey.key, GenerateKey.ivspec);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            return encStr;
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            return encStr;
        }

        byte encData[] = DatatypeConverter.parseBase64Binary(encStr.substring(ENCRYPTED_TAG.length()));
        ByteArrayInputStream bin = new ByteArrayInputStream(encData);
        CipherInputStream in = new CipherInputStream(bin, cr);
        byte data[] = new byte[encStr.length() * 2];
        try {
            in.read(data);
            in.close();
            return new String(data).trim();
        }catch(IOException e){
            e.printStackTrace();
        }
        return encStr;
    }

    //Loads the a text file content
    private static String loadFileContent(String fileName) {
        try {
            File f = new File(fileName);
            byte data[] = new byte[(int) f.length()];
            FileInputStream in = new FileInputStream(f);
            in.read(data);
            in.close();
            return new String(data);
        } catch (Exception err) {
            return null;
        }
    }

    /**
     * Receive a filename and seeks all the defined tags in it and encrypt them.
     * @param  filename  The filename to seek the tags and encrypt
     */
    public static void encryptCredentialAttributes(String filename) {
        // No Key, hence disabled
        if (GenerateKey.key == null)
            return;

        String originalData = loadFileContent(filename);
        if (originalData == null)
            return;

        String lowerCaseData = originalData.toLowerCase();
        boolean encryptedAValue = false;

        for (TAG t : tagsToEncrypt) {
            t.reset();
            String data = t.next(lowerCaseData, originalData);
            while (data != null) {
                if (data.startsWith(ENCRYPTED_TAG)) {
                    data = t.next(lowerCaseData, originalData);
                } else {
                    encryptedAValue = true;
                    String eData = encrypt(data);
                    StringBuffer buffer = new StringBuffer();
                    buffer.append(originalData.substring(0, t.x2 + 1));
                    buffer.append(eData);
                    buffer.append(originalData.substring(t.y1));
                    originalData = buffer.toString();
                    lowerCaseData = originalData.toLowerCase();
                    data = t.next(lowerCaseData, originalData);
                }
            }
        }
        if (encryptedAValue) {
            try {
                FileOutputStream out = new FileOutputStream(filename);
                out.write(originalData.getBytes());
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Receive a filename and seeks all the defined tags in it and decrypt them.
     * @param  filename  The filename to seek the tags and decrypt
     */
    public static StreamSource decryptCredentialAttributes(String filename) {
        if(filename==null)
            return null;
        String originalData = loadFileContent(filename);
        // No Key, hence disabled
        if (GenerateKey.key == null)
            return new StreamSource(new File(filename));
        if (originalData == null)
            return new StreamSource(new File(filename));

        int index = originalData.indexOf(ENCRYPTED_TAG);
        while (index != -1) {
            int index1 = originalData.indexOf("<", index);
            String eData = originalData.substring(index, index1);
            String data = decrypt(eData);
            StringBuffer buffer = new StringBuffer();
            buffer.append(originalData.substring(0, index));
            buffer.append(data);
            buffer.append(originalData.substring(index1));
            originalData = buffer.toString();
            index = originalData.indexOf(ENCRYPTED_TAG);
        }
        return new StreamSource(new ByteArrayInputStream(
                originalData.getBytes()));
    }

    private static class TAG {
        private String startTag = null;
        private int x1 = -1;
        private int x2 = -1;
        private int y1 = -1;

        public TAG(String _tag) {
            this.startTag = "<" + _tag;
        }

        public void reset() {
            this.x1 = -1;
            this.x2 = -1;
            this.y1 = -1;
        }

        public String next(String lowerCase, String originalTXT) {
            x1 = lowerCase.indexOf(startTag, x1 + 1);
            if (x1 == -1)
                return null;
            x2 = lowerCase.indexOf(">", x1);
            if (x2 == -1)
                return null;
            y1 = lowerCase.indexOf("<", x1 + 1);
            if (y1 == -1 || y1 < x2)
                return null;
            return originalTXT.substring(x2 + 1, y1);
        }
    }
}